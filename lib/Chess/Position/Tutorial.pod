=head1 NAME

Chess::Position::Tutorial - An Introductory Tutorial to Chess Programming in
Perl With C<Chess::Position>

=head1 DESCRIPTION

Let's start by explaining the fundamental data structures.

=head2 Data Structures

=head3 Bitboards

A real chess board looks roughly likes this:

      a   b   c   d   e   f   g   h
    +---+---+---+---+---+---+---+---+
  8 | r | n | b | q | k | b | n | r |
    +---+---+---+---+---+---+---+---+
  7 | p | p | p | p | p | p | p | p |
    +---+---+---+---+---+---+---+---+
  6 |   | . |   | . |   | . |   | . |
    +---+---+---+---+---+---+---+---+
  5 | . |   | . |   | . |   | . |   |
    +---+---+---+---+---+---+---+---+
  4 |   | . |   | . |   | . |   | . |
    +---+---+---+---+---+---+---+---+
  3 | . |   | . |   | . |   | . |   |
    +---+---+---+---+---+---+---+---+
  2 | P | P | P | P | P | P | P | P |
    +---+---+---+---+---+---+---+---+
  1 | R | N | B | Q | K | B | N | R |
    +---+---+---+---+---+---+---+---+
      a   b   c   d   e   f   g   h

The board has eight columns, called "files", named "a" to "h", and eight
rows, called "ranks", named "1" to "8". The initial position of the
white king "K" is "e1", the intersection of the "e" file and the "1"st
rank. Likewise, the white queen "Q" is on "d1", and the black king "k"
and black queen "q" are initially located on "e8" and "d8" respectively.

It is, of course, possible to use an intuitive board representation like
an array of arrays or even a hash, and there are chess libraries that do
exactly that. The main drawback of this approach is performance because
all operations on the board imply expensive lookups and dereferencings.

A more efficient representation takes advantage of the fact that a chess
board has exactly 64 squares. Nowadays, most computers use integers of
size 64. Therefore you can represent a chess board, more exactly one single
aspect of a chess board, as a 64-bit integer, each bit representing
exactly one square of the board.

But with just one bit of information per square, you cannot represent a
chess position, because there are 12 different pieces: Pawns, knights,
bishops, rooks, queens, and kings in both black and white. The solution
is to use multiple such bitboards, and combine them.

A C<Chess::Position> instance is an array of arrays of integers, and the
first few are:

=over

=item * C<w_pieces> - one bitboard for the white pieces

=item * C<b_pieces> - one bitboard for the black pieces

=item * C<pawns> - one bitboard for the pawns (of both colors)

=item * C<knights> - one bitboard for the knights (of both colors)

=item * C<bishops> - one bitboard for the bishops (of both colors)

=item * C<rooks> - one bitboard for the rooks (of both colors)

=item * C<checkers> - one bitboard for all pieces giving check (of the color
not to move)

=item * C<kings> - one bitboard for the kings (of both colors)

=back

Why is there no distinction between black and white pieces of a certain
kind, for example black knights and white knights? The answer is
performance and compactness. To get a bitboard with one bit set for each
black knight, you simple do the bitwise AND of the two bitboards:

    $black_knights = $b_pieces & $knights

In other words: For each black knight, there must be one bit set in the
bitboard of black pieces AND in the knight bitboard.

Example: How to get a bitboard of white's regular (bishops, knights,
rooks, and queens) pieces:

    $w_pieces & ($knights | $bishops | $rooks)

Now you probably ask yourself, why there is no bitboard for the queens.

The main purpose of bitboards is to generate a list of possible resp.
legal moves in a certain position, and to find out which squares the
pieces control or attack. In that respect, a queen is simply a
combination of a bishop and a rook.

When the moves are getting generated, it would be an inefficient waste
of time to generate the queen moves in a separate step. Look at it:

=over

=item 1. generate (diagonal) bishop moves

=item 2. generate (horizontal and vertical) rook moves

=item 3. generate diagonal queen moves

=item 4. generate horizontal and vertical queen moves

=back

This can be done faster

=over

=item 1. generate diagonal bishop and queen moves

=item 2. generate horizontal and vertical rook and queen moves

=back

To find out, whether the move is performed by a queen or a bishop or
rook, you just have to look at the starting square of the move. If it is
occupied by a queen, it is a queen move, otherwise a bishop or rook
move.

The drawback of this is that it is a little more complicated to get a
bitboard of the bishops, rooks, and queens:

    $white_queens = $w_pieces & $bishops & $rooks
    $white_rooks = $w_pieces & ($rooks & ~$bishops)
    $white_bishops = $w_pieces & ($bishops & ~$rooks)

But these bitwise operations are very fast and cheap, and in fact, you
rarely have to find out whether a square is really occupied by a queen
or a rook.

=head3 Other Board Representations

=head4 Forsyth-Edwards Notation FEN

The Forsyth-Edwards Notation of a chess position is mostly used for data
exchange between chess software. See for example
L<https://en.wikipedia.org/wiki/Forsyth%E2%80%93Edwards_Notation>
for details.

=head4 Extended Position Description EPD

A similar notation to FEN is the L<https://en.wikipedia.org/wiki/Extended_Position_Description>.
You can think of it as FEN with meta data.

=head3 Coordinates and Squares

The chess board is actually a Cartesian coordinate system. There are
multiple ways, how a particular point in that coordinate system can be
specified. In C<Chess-Position> we use the terms "coordinates",
"squares", and "shifts", and you can convert between all of them with
dedicated class methods:

=over

=item C<my $square = Chess::Position-E<gt>coordinatesToSquare($file, $rank)>

=item C<my $shift = Chess::Position-E<gt>coordinatesToShift($file, $rank)>

=item C<my $shift = Chess::Position-E<gt>squareToShift($square)>

=item C<my ($file, $rank) = Chess::Position-E<gt>squareToCoordinates($square)>

=item C<my $square = Chess::Position-E<gt>shiftToSquare($shift)>

=item C<my ($file, $rank) = Chess::Position-E<gt>shiftToCoordinates($shift)>

=back

Additionally, we also have "shift masks" (see below).

=head4 Coordinates

When we talk of coordinates, we mean a pair of a file and a rank, but
always as 0-based indexes. So the files "a" to "h" are indexed as
0 ... 7, and the ranks "1" to "8" are indexed as 0 ... 7.

=head4 Squares

Squares are conventional coordinates like "e4" or "c7". They are only
used for presentational purposes.

=head4 Shifts

A bitboard has 64 bits, and each bit stands for a particular square of
the chess board:

       a  b  c  d  e  f  g  h
    8 63 62 61 60 59 58 57 56 8
    7 55 54 53 52 51 50 49 48 7
    6 47 46 45 44 43 42 41 40 6
    5 39 38 37 36 35 34 33 32 5
    4 31 30 29 28 27 26 25 24 4
    3 23 22 21 20 19 18 17 16 3
    2 15 14 13 12 11 10  9  8 2
    1  7  6  5  4  3  2  1  0 1
       a  b  c  d  e  f  g  h

So the square "e4" is represented by the bit with the index 27 of a
bitboard (actually the 28th bit if you count from 1). So, a better term
may actually be "index" or "bit number".

=head4 Shift Masks

How would you find out whether the square "e4" is occupied by a white
piece? You create a bitboard (64-bit integer) where only the 27th bit is
set and AND that with the bitboard of the white pieces. And you create a
bitboard where only the 27th bit is set with a shift operation:

    $e4_square = (1 << 27) | $w_pieces

You "shift" the one 27 places to the left. And this is why the indexes
or bit numbers are called "shifts" here. And a shift mask is a bitboard
with exactly one bit set.

=head3 C<Chess::Position> Instances

Unlike most Perl objects, instances of C<Chess::Position> are blessed
array references. This design decision was taken because accessing
accessing array elements is faster than accessing hash elements. But
there is no need to remember the exact ordering of the array. You can
either use dedicated macros that operate directly on
C<Chess::Position> instances or use constants for the indexes:

 use Chess::Position (:all);
 use Chess::Position::Macro;
 
 $pos = Chess::Position->new;
 
 # Equivalent!
 $w_pieces = $pos[CP_POS_W_PIECES];
 $pos[CP_POS_W_PIECES] = $_pieces;
 $w_pieces = cp_pos_w_pieces $pos;
 cp_pos_w_pieces $pos = $w_pieces;

=head3 Pieces

The chess pieces are specified by an enumeration:

=over

=item * C<CP_NO_PIECE> 0

=item * C<CP_PAWN> 1

=item * C<CP_KNIGHT> 2

=item * C<CP_BISHOP> 3

=item * C<CP_ROOK> 4

=item * C<CP_QUEEN> 5

=item * C<CP_KING> 6

=back

The default values for each piece are defined by these constants in
C<Chess::Position>:

=over

=item * C<CP_PAWN_VALUE> 100

=item * C<CP_KNIGHT_VALUE> 300

=item * C<CP_BISHOP_VALUE> 300

=item * C<CP_ROOK_VALUE> 500

=item * C<CP_QUEEN_VALUE> 900

=back

These constants can be overridden in derived classes. This is not
recommended for the constants specifiying the pieces (see above), as the
data values will not fit into the other structures.

=head3 Moves

=head4 Internal Move Representation

A move in C<Chess::Position> is simply an integer. There is also a
convenience class C<Chess::Position::Move> but this class is not used
internally for performance reasons. The individual bits of a move are:

=over

=item * 16-18 (15-17): piece that moves (resp. attacker)

=item * 13-15 (12-14): promotion piece

=item * 7-12 (6-11): from shift (0-63)

=item * 1- 6 (0- 5): to shift (0-63)

=back

I<The numbers in parentheses are the 0-based bit numbers.>

Only bits 1 to 15 are really needed to characterize a move, and the bits
13 to 15 are only needed for pawn promotions. The other bits can be
derived from the position that the move is applied to.

The piece that moves, the attacker is the piece that stands on the
starting square.  Note that this is never C<CP_QUEEN> even if the piece that
moves is a queen.  It is either C<CP_BISHOP> or C<CP_ROOK> for queen moves,
depending on how the queen moves.  This is a little bit confusing but has a
marginal performance advantage.

You do not have to remember the exact structure of a move but use macros
resp. inline functions for accessing individual properties:

=over

=item * C<cp_move_to($move)>: the starting square as a shift

=item * C<cp_move_from($move)>: the destination square as a shift

=item * C<cp_move_promotion($move)>: the promotion piece

=item * C<cp_move_attacker($move)>: the attacking piece

=back

None of these macros can be used as l-values (on the left-hand side of
an assignment)! For this, use other macros:

=over

=item * C<cp_move_set_to($move, $to)>: the starting square as a shift

=item * C<cp_move_set_from($move, $from)>: the destination square as a shift

=item * C<cp_move_set_promotion($move, $piece)>: the promotion piece

=item * C<cp_move_set_attacker($move, $piece)>: the attacking piece

=back

=head4 Parsing Moves

The method C<parseMove()> can be used for creating a move.  It expects the
move in either:

=over 4

=item Coordinate Notation

=item Standard Algebraic Notation (SAN)

=back

The coordinate notation is the notation that most chess engines use.  It is
simply the start and the destination square appended plus an optional piece
to promote a pawn to, for example "b1c3" for the piece on square "b1" moving
to "c3" or "e7d8q" for a pawn on "e7" capturing the piece on "d8" being promoted
to a queen.

Standard Algebraic Notation (SAN) is the notation conventionally used for
describing chess games. You will find more information about it on the internet.

Note that the move parser is very forgiving and accepts a lot of moves that
are not complying with the standard.

=head2 Using Macros

When dealing with chess programming you often find yourself executing
small operations many times, more than often millions of times. You can,
of course, write subroutines for these operations but the calling
overhead sums up and contributes significantly to the execution time of
your code.

Even writing these routines in C does not help at all because the
calling overhead is large compared to the execution time of the function
body.

This is why the module C<Chess::Position::Macro> exists. It makes a lot
of small helper functions available, the names of which all begin with
C<cp_>. You can use them more or less like functions but they are inlined
into your code at compile-time.

There are a couple of things that you have to keep in minde, when using
these macros:

=head3 Use C<Chess::Position::Macro> and(!) C<Chess::Position>

The macros in C<Chess::Position::Macro> make use of constants defined in
C<Chess::Position>. If you do not import these constants, you will get
strange errors. You should therefore start your own code with this
boilerplate:

 use strict;
 use integer;
 use Chess::Position qw(:all);
 use Chess::Position::Macro;

=head3 Use C<integer>

Some of the macros will only work on integers. You must therefore always
C<use integer> in the scope of your code.  Not doing so will result in
errors!

If you need floating point arithmetics, activate them only in the limited
scope of a block:

    {
        no integer;
        printf "avg. loss in centipedes: %g\n", $score / 100;
    }

=head3 Do not Create References to Macros

Macros are not Perl subroutines. They are more or less stupidly replaced
with chunks of code. Things like C<my $sub = \&cp_pos_w_pieces> may or
may not cause a syntax error but they will never do what you expect.

=head3 Be Prepared for Errors

The macro expansion internally makes use of C<PPI::Document> and it
therefore shares all of that module's inevitable limitations. And it
adds a fair amount of its own shortcomings. The macro approach is rather
an experiment than a production-ready general-purpose tool.

=head2 Common Bitboard Operations

Bitboards are fast and efficient but working with them is a little bit
convoluted compared to more conventional representations of a chess
board like two-dimensional arrays or hashes.

=head3 Counting Pieces

Task: Count the number of white pawns on the board.

 use Chess::Position;
 use Chess::Position::Macro;
 
 my $pos = Chess::Position->new;
 my $white_pawns = cp_pos_w_pieces($pos) & cp_pos_pawns($pos);
 my $count;
 cp_bb_popcount $white_pawns, $count;
 print "There are $count white pawns on the board.\n";

The important line is the last but one. The macro C<cp_bb_popcount>
counts the number of bits set in an integer, and this is exactly what
you need here.

=head3 Iterating Bitboards

Task: Print the square for every white pawn on the board.

=head4 Conventional and Slow Approach

Iterating over a bitboard can be done in an intuitive and straightforward way:

    use integer;
    use Chess::Position qw(:all);
    use Chess::Position::Macro;

    my $white_pawn_mask = cp_pos_w_pieces($pos) & cp_pos_pawns($pos);

    foreach my $shift (0 .. 63) {
        my $shift_mask = 1 << $shift;

        if ($shift_mask & $white_pawn_mask) {
            my $square = cp_shift_to_square $shift;
            print "There is a white pawn on $square.\n";
         }
    }

You basically shift a 1 bit subsequently to the left, and then test whether the
corresponding bit is set in the bitboard.  There is nothing wrong with this
approach and it is actually reasonably fast.

=head4 Efficient and Fast Approach

But there is a better technique to achieve the same result:

    use integer;
    use Chess::Position qw(:all);
    use Chess::Position::Macro;

    my $pos = Chess::Position->new;
    my $white_pawn_mask = cp_pos_w_pieces($pos) & cp_pos_pawns($pos);

    while ($white_pawn_mask) {
        my $shift_mask = cp_bb_clear_but_least_set $white_pawn_mask;
        my $shift = cp_bb_count_trailing_zbits $shift_mask;

        my $square = cp_shift_to_square $shift;
        print "There is a white pawn on $square.\n";

        $white_pawn_mask = cp_bb_clear_least_set $white_pawn_mask;
    }

The macro `cp_bb_clear_but_least_set()` clears all bits in a bitboard except
for the last significant one.  If you count the trailing zero bits with the
macro `cp_bb_count_trailing_zbits()` you get the position of that bit in the
bitboard and you can now use that information for whatever you want to do.

At the end of the loop body, you clear the least significant bit of the
bitboard.  Therefore, the population count of the bitboard decreases by
one with each iteration.

If you want to benchmark both approaches, make sure to remove the expensive
operations inside the loop body, that is the call to `cp_shift_to_square()`
and especially the print to the console.

What you will find out is that the second approach runs around 10-15 %
faster than the conventional approach.  On the one hand you have less
iterations (8 vs. 64) but masking out the bits and especially counting the
trailing zero bits outweighs that mostly.

But if you replace "pawn" with "king" in the code, the 2nd variation runs
around 700 % or seven times faster than the conventional approach.  This is
because you always have exactly one loop iteration instead of 64.  And in
the case of kings you could improve that even further by taking advantage of
the fact that there is always exactly one white king on the board.  So you
do not even need a loop.

Most of the time, the bitboards you are dealing with are sparsely populated
and it is advantageous to take the second approach.  Only in the exceptional
case that you want to iterate over a bitboard with all pieces of one color
or even all pieces of both colors, you are better off using the conventional
approach.

=head2 Game Play

=head3 Initializing a Position

You use the constructor to instantiate a chess position.  For the start
position you call it with arguments.  If you have the position represented
as a string in Forsyth-Edwards Notation (FEN) you pass that as an
argument to the constructor:

    $pos = Chess::Position->new;

    # Or:

    $fen = 'r4rk1/1p3pp1/1q2b2p/1B2R3/1Q2n3/1K2PN2/1PP3PP/7R w - - 3 22';
    $pos = Chess::Position->new($fen);

=head3 Making Moves

Applying a move to a position usually requires first parsing a chess move
as a string into the internal representation.  You then pass that move
(which is just an integer) to the method C<doMove()>:

    # Parse the move in one of the supported formats.
    $move = $pos->parseMove('Nc3');
    $move = $pos->parseMove('Nb1-c3');
    $move = $pos->parseMove('b1c3');
    $state = $pos->doMove($move) or die "illegal move";

The method C<doMove()> returns a reference to an array containing state
information needed to undo the move later.  If the move was illegal,
the method returns a falsy value.

=head3 Undoing Moves

You will often find that you have to undo a move so that the position is
reverted to the state before the move had been played.

In general, there are two strategies for undoing moves in chess software.
The brute force approach is to make a deep copy of the position and revert
by copying back later, resp. by simply applying the move to the copy only and
throw it away.

The other possibility is to undo all modifications makde by applying the
move.  This is, of course, more complicated but often faster than the brute
force approach.

L<Chess::Position> supports both approaches and currently the brute force
approach seems to be faster (around 10-15 percent) but this maybe depends on
the hardware or system.  The reason for that is that a shallow copy is
sufficient for copying a L<Chess::Position> which makes the copying really
cheap, whereas undoing a move programmatically requires several dereferencings.

But you are encouraged to try it out yourself.

=head4 Undoing Moves Programmatically

This is done with C<undoMove()>:

    $state = $pos->doMove($move);
    $pos->undoMove($move, $state);

Not all recovery information can be stored in the move itself.  Therefore,
you have to pass the state information return from C<doMove()> as the
second argument to C<undoMove()>.

=head4 Undoing Moves By Copying the Position

How you do this depends a little bit on your exact requirements.  It will
probably look something like this:

    $copy = bless [@$pos], 'Chess::Position'; # or $copy = $pos->copy;
    $pos->do_move($move);

There is also a copy constructor C<copy()> but when you are really concerned
about performance, then you probably choose the manual copying because it
safes you a method call.

=head3 Playing Games in PGN Format

Playing games stored in Portable Game Notation PGN can be done with the
external library L<Chess::PGN::Parse>.  Note that a PGN file can actually
contain a collection of games, not just one:

    $pos = Chess::Position->new;
    $pgn = Chess::PGN::Parse->new('games.pgn') or die;
    while ($pgn->read_game) {
        $pgn->parse_game;
        @san_moves = $pgn->moves;
        foreach my $san_move (@san_moves) {
            $move = $pos->parseMove($san_move)
                or die "cannot parse move '$san_move'";
            $pos->doMove($move)
                or die "illegal move '$san_move'";
        }
    }

=head2 Analyzing Positions

L<Chess::Position> offers some high-level methods for analyzing chess
positions.

=head3 Listing Possible Moves

You have to ways to do this:

    @moves = $pos->legalMoves;
    foreach $move (@moves) {
        print join '|', $pos->SAN($move), $pos->coordinateNotation($move);
    }

Chess engines usually do not try out every legal move for each position but
prune parts of the search tree by discarding moves which do not make sense.
Therefore, the move generator in L<Chess::Position> works in two stages.
The above example could be re-written like this:

    @moves = $pos->pseudoLegalMoves;
    foreach $move (@moves) {
        $pos->doMove($move) or next;
        $pos->undoMove($move);
        print join '|', $pos->SAN($move), $pos->coordinateNotation($move);
    }

The method C<pseudoLegalMoves> may return moves that violate the rules of
chess.  But checking the rules is somewhat expensive.  If the loop above
may be exited early (this will often happen in chess engines), then these
extra checks are a waste of time, when you never actually consider the move.

What exactly is a pseudo-legal move is implementation dependent and you should
not rely on the current implementation.

=head3 Visualizing Bitboards

A bitboard, which is just a 64 bit integer, can be visualized in a
chess-board-like manner with C<dumpBitboard()>.

    print "white pieces: ", $pos->dumpBitboard($pos->[CP_POS_WHITE_PIECES]);

There is also a method C<dumpAll()> which dumps all bitboards at once.

=head3 Checking for Check

Finding out whether the side to move is in check, can be done like this:

    $checkers = $pos->[CP_POS_IN_CHECK];
    # or: $checkers = cp_pos_in_check $pos;
    if ($checkers) {
        print "pieces giving check: ", $pos->dumpBitboard($checkers);
    }

In fact, what you get is not a boolean flag but a bitboard with the pieces
that are giving check.

=head3 Checking for Pieces

Finding out whether a white piece is on "e4" can be done like this:

    $shift = $pos->squareToShift('e4');
    # or $shift = $pos->coordinatesToShift(4, 0); 
    $mask = 1 << $shift;
    $is_white = $mask & $pos->[CP_POS_WHITE_PIECES];
    # or: $is_white = $mask & cp_pos_white_pieces($pos);

If you want to know whether it is a white king, you go like this:

    $is_king = $mask & ($pos->[CP_POS_WHITE_PIECES] & $pos->[CP_POS_KINGS]);
    # or: $is_king = $mask & (cp_pos_white_pieces($pos) & cp_pos_kings($pos));

For bishops, queens, and rooks, you have to keep in mind that there is no
bitboard for queens:

    $is_queen = $mask & cp_pos_bishops($pos) & cp_pos_rooks($pos);
    $is_rook = $mask & ~cp_pos_bishops($pos) & cp_pos_rooks($pos);
    $is_bishop = $mask & cp_pos_bishops($pos) & ~cp_pos_rooks($pos);

If you want to also check for the color, you additionally have to do the
bitwise AND of the white or black bitboard.

Finding out which piece is on a particular location can be done with
dedicated methods:

    ($piece, $color) = $pos->pieceAtSquare('e4');
    ($piece, $color) = $pos->pieceAtCoordinates(4, 3);
    ($piece, $color) = $pos->pieceAtShift(27);
    $piece = $pos->pieceAtSquare('e4');
    $piece = $pos->pieceAtCoordinates(4, 3);
    $piece = $pos->pieceAtShift(27);

In array context, you get the piece and the color, in scalar context just the
piece.  The piece is one of C<CP_PAWN>, C<CP_KNIGHT>, C<CP_BISHOP>,
C<CP_QUEEN>, or C<CP_KING>, and the color one of C<CP_WHITE>, C<CP_BLACK>,
or C<undef> if there is no piece at all at the specified location.

=head3 Castling State

The castling state is encoded with other state information in one single
integer as a bit mask.  It is highly recommended that you use the macros
from L<Chess::Position::Macro> for it:

    $white_can_castle_king_side  = cp_pos_w_ks_castle $pos;
    $white_can_castle_queen_side = cp_pos_w_qs_castle $pos;
    $black_can_castle_king_side  = cp_pos_b_ks_castle $pos;
    $black_can_castle_queen_side = cp_pos_b_qs_castle $pos;

=head3 En Passant

You should also use a macro from L<Chess::Position::Macro>:

    $en_passant_shift = cp_pos_ep_shift $pos;

This will be 0 if capturing en passant is not possible in the particular
position.  You may have to be careful to use this information because 0 is
also the "shift" for the square "h1".  In doubt, go like this:

    $ep_shift = cp_pos_ep_shift $pos;
    if ($ep_shift && $ep_shift == $location) {
        # do what you need ...
    }

=head3 Evading a Check

A check can be defended in one of three ways:

=over 4

=item Moving the King

This is always an option.

=item Capturing the Piece Giving Check

This is only an option if there is just one piece giving check (because you
cannot capture multiple pieces at once).

=item Blocking the Check With a Piece

You can also block the check by moving a piece between the king and the
opponent's piece giving check.  But this is not an option if multiple pieces
give check, or if the piece giving check is a queen, a rook, or a knight.

Why? If the piece giving check is a pawn, there is no space between it and
the king, and a knight can jump over other pieces.

=back

This information is always stored in a L<Chess::Position> object:

    $evasion_strategy = cp_pos_evasion $pos;
    } if (CP_EVASION_KING_MOVE == $evasion_strategy) {
        say "king must move";
    } elsif (CP_EVASION_CAPTURE) {
        say "king can move or piece giving check can be captured";
    } elsif (CP_EVASION_ALL == $evasion_strategy) {
        say "king can move, attacker can be captured, or check can be blocked:",
            $pos->dumpBitboard(cp_pos_evasion_squares($pos));
    }

Remember that the item at C<CP_POS_IN_CHECK> gives you a bitboard with all
pieces giving check.  Alternatively, you can use the macro C<cp_pos_in_check>.

The bitboard at C<CP_POS_EVASION_SQUARES> has bits set for all pieces giving
check.
