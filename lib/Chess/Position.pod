=head1 NAME 

Chess::Position - A comprehensive chess library for Perl

=head1 SYNOPSIS

    use Chess::Position(:all);

    $pos = Chess::Position->new;
    $pos = Chess::Position->new('k7/8/8/8/8/8/8/7K w - - 0 1');

=head1 DESCRIPTION

B<Chess-Position> is a comprehensive chess library for Perl, aiming at being
as fast and efficient as possible for a scripting language.  It is also
somewhat opinionated but this is not an end in itself but owed to its intention
of being fast and efficient.  In doubt, flexibility is sacrificed for
performance and efficiency.

The library features:

=over 4

=item bitboards for board representation

=item macros/inline functions for often used computations

=item pseudo-legal move generation

=item legality checks for moves

=item magic bitboards for generation of sliding piece moves and attacks

=item FEN (Forsyth-Edwards Notation) import and export

=back

For a gentler introduction, please see L<Chess::Position::Tutorial>.  The rest
of this document contains reference documentation only.

If performance is key for you, you are strongly advised to have a look at
L<Chess::Position::Macro> which documents macros resp. inline functions that
speed up tasks that can be done with L<Chess::Position> significantly.

The class exports a number of constants that can either be imported
individually, by export tag, or all at once by the export tag ':all'.  All
constants are prefixed with 'CP_' and you will have little reason to not
import all constants.

=head2 Internals

An instance of a B<Chess::Position> is a blessed array reference.  You can
access its properties through accessor macros or by using constants for
the array indices.

A move in B<Chess::Position> is a regular scalar, more precisely an unsigned
integer. You can access its properties with the move methods described below.

It is guaranteed that every legal chess move is represented by an non-zero
integer.  It is therefore safe to use moves in boolean context.

=head2 Terminology

For the sake of brevity, this document uses the following terms without
further explanation:

=over 4

=item I<Square>

A square is a square of the chess board as a string like "e4" or "f7".

=item I<Coordinates>

Coordinates are a pair of a file (0-7) and a rank (0-7).

=item I<Shift>

A "shift" is an integer in the range of 0-63 where 0 is the shift for "a1" and
63 is the shift for "h8".

=item I<Bitboard>

A bitboard is an unsigned 64-bit integer.  Each bit stands for one square of
the chess board.

=item I<Mask>

A mask is a bitboard with exactly one bit set.  The mask representing "e4" is
a 1 shifted left 28 bits, because the shift for "e4" is 28.

=item I<Move>

When an argument is called "move", it is really an integer representing a chess
move.

=item I<Notation>

When an argument is called "notation", it is a supported notation of a chess
move, either Standard-Algebraic Notation SAN or coordinate notation.

=back

=head2 Limitations

B<Chess::Position> requires 64-bit support for Perl.  It will not run on
32-bit Perls.

=head2 Similar Software

L<Chess::Rep> and L<Chess::Play> provide similar functionality.  Both compile
a lot faster than B<Chess::Position> but once compiled, a perft test of
B<Chess::Position> runs more than 30 times faster than one of L<Chess::Play>
and more than 100 times faster than one of L<Chess::Rep>.

At the time of this writing, B<Chess::Position> also outperforms
L<python-chess|https://python-chess.readthedocs.io/en/latest/> by about 50 %.

=head1 CONSTRUCTORS

=over 4

=item B<new([FEN])>

Creates a new B<Chess::Position> instance that represents the starting position
of standard chess.

If an argument is passed to the constructor, it is interpreted as a position in
Forsyth-Edwards Notation (FEN).  This has the same effect as using the
constructor C<newFromFEN>.

=item B<newFromFEN(FEN)>

Creates a new B<Chess::Position> instance from a string containing the
Forsyth-Edwards Notation (FEN) of a chess position.  The only difference to
C<new()> is that the string argument is required. 

This constructor may throw an exception if the described position does not meet
the requirements of the library.

All legal chess positions meet the requirements of the library.  But positions
that are not legal and may cause the library to malfunction, are rejected.

=item B<copy(POSITION)>

Clones B<POSITION>.

=back

=head1 OVERLOADED OPERATORS

In string context, the position is encoded in Forsyth-Edwards Notation.  No
other operators are overloaded.

Note that the Forsyth-Edwards Notation does not cover all aspects of a chess
position, especially the history of moves.  String-wise equality of two
instances of a B<Chess::Position> does therefore not imply that the two
positions are identical.  Use the method L</equal> for a strict equality
check.

=head1 METHODS

=head2 General Methods

=over 4

=item B<toFEN>

Renders the position to Forsyth-Edwards Notation.  Alternatively, you can just
use the object as a string:

    $position = Chess::Position->new;
    say $position->toFEN;
    say "$position"; # Does the same as above.

=item B<legalMoves>

Returns a list of legal moves for the current position.  A move is just an
integer.

=item B<pseudoLegalMoves>

Generates all pseudo-legal moves for the current position.

Pseudo-legal are all moves that can be executed by the pieces on the side to
move ignoring whether the side to move is in check after the move.

Only the lower 16 bits of the move are set, that means the start and destination
square, a possible promotion piece and the en passant flag in case the move
is an en passant capture.

=item B<equals(POSITION)>

Returns true if the current position is equivalent to B<POSITION>.

=back

=head2 Methods for Accessing Position Properties

=over 4

=item B<whitePieces>

Returns the bitboard of all white pieces.

=item B<blackPieces>

Returns the bitboard of all black pieces.

=item B<occupied>

Returns the bitboard of all squares that are occupied by any piece.

=item B<vacant>

Returns the bitboard of all squares that are not occupied by any piece.

=item B<kings>

Returns the bitboard of all kings (black and white).

=item B<queens>

Returns the bitboard of all queens (black and white).

=item B<rooks>

Returns the bitboard of all rooks (black and white).

=item B<bishops>

Returns the bitboard of all bishops (black and white).

=item B<knights>

Returns the bitboard of all knights (black and white).

=item B<pawns>

Returns the bitboard of all pawns (black and white).

=item B<toMove>

Returns the side to move, either L</CP_BLACK> or L</CP_WHITE>.

=item B<halfMoves>

Returns the number of half-moves made.  Initially, this is 0.  After white has
made their first move, it is 1. After black has made their first move, it is
2, and so on.

=item B<halfMoveClock>

Returns the number of reversible moves immediately leading to the current
position.  The following moves are irreversible:

=over 4

=item Pawn moves

Reason: A pawn cannot move backwards.

=item Captures

Reason: Captured pieces are gone for good.

=item First king move of each side

Reason: The side to move loses the castling rights.

=item First move of each rook of each side

Reason: The side to move loses at least one of their castling rights.

=item Castlings

Reason: The side to move loses the castling rights.  This is also implied by
the fact that they are necessarily the first king move.

=back

The half-move-clock is important because both players can claim a draw, when
the half-move clock has reached 50.

=item B<inCheck>

Returns false if the side to move is not in check, a truthy value otherwise.
The truthy value returned is a bitboard of all pieces giving check.

=item B<evasion>

If the side to move is in check, returns the required check evasion strategy:

=over 4

=item L</CP_EVASION_KING_MOVE>

The king must move.  This is the case, when multiple pieces give check.

=item L</CP_EVASION_CAPTURE>

Either the king must move or the piece giving check must be captured.

=item L</CP_EVASION_ALL>

Either the king must move, the piece giving check must be captured, or another
piece must be moved between the king and the attacking piece.

=back

=item B<evasionSquares>

If a check can be evaded by moving a piece between the king and the attacking
piece of the opponent, this bitboard gives all squares where the check can be
blocked.  These are all squares between the king and the attacking piece,
including the square where the attacking is standing.

=item B<enPassantShift>

If en-passant is possible, returns the shift of the square where the capturing
pawn has to move.  If en-passant is not possible, 0 is returned.  0 happens to
be the shift of "a1" but "a1" is not a valid en-passant square.  It is
therefore safe to use this method in boolean context.

=item B<material>

Gives the material balance from the perspective of the white player.  That
means that all white pieces have a positive value, and all black pieces have
a negative value.

The values are:

=over 4

=item L</CP_QUEEN_VALUE> for each queen

=item L</CP_ROOK_VALUE> for each rook

=item L</CP_BISHOP_VALUE> for each bishop

=item L</CP_KNIGHT_VALUE> for each knight

=item L</CP_PAWN_VALUE> for each pawn

=back

These constants can be overridden by inheriting from B<Chess::Position>.

Note: Kings do not count!

=item B<whiteKingSideCastlingRight>

Returns a truthy value if white still has the right to castle king-side
("O-O"), false otherwise.

=item B<whiteQueenSideCastlingRight>

Returns a truthy value if white still has the right to castle queen-side,
("O-O-O"), false otherwise.

=item B<blackKingSideCastlingRight>

Returns a truthy value if black still has the right to castle king-side
("O-O"), false otherwise.

=item B<blackQueenSideCastlingRight>

Returns a truthy value if black still has the right to castle queen-side,
("O-O-O"), false otherwise.

=item B<castlingRights>

Returns a bitmap of castling rights for the current position:

=over 4

=item 0x1 is set if white can still castle king-side

=item 0x2 is set if white can still castle queen-side

=item 0x4 is set if black can still castle king-side

=item 0x8 is set if black can still castle queen-side

=back

=item B<kingShift>

Return the shift of the square of the king of the side to move.  This
information is needed internally.

=item B<info>

Returns an integer encoding various other aspects of the position.  You do not
need this because there are dedicated methods available for all these
properties.

=back

=head2 Move Methods

=over 4

=item B<parseMove(NOTATION)>

Parses the string B<NOTATION> into an integer representing the move or returns
false, if the B<NOTATION> cannot be parsed or is an illegal move.

B<NOTATION> can either be a move in Standard Algebraic Notation (SAN) or in
coordinate notation.  Coordinate notation is the format used by most chess
engine and is the concatenation of the start and destination square and a
possible promotion piece, for example "e2e4" or "f2f1q".

=item B<SAN(MOVE)>

Renders the integer B<MOVE> into Standard-Algebraic Notation SAN, for example
"e4", "Bxc4", "O-O", or "fxe1=Q".

=item B<coordinateNotation(MOVE)>

Renders the integer B<MOVE> into coordinate notation, for example "e2e4" or
"f2f1q".

=item B<moveFrom(MOVE)>

Extracts the shift (0-63) of the starting square.

=item B<moveTo(MOVE)>

Extracts the shift (0-63) of the destination square.

=item B<movePromote(MOVE)>

Extracts the piece that a pawn is promoted to if the move is a promotion.
Returns either L</CP_QUEEN>, L</CP_ROOK>, L</CP_BISHOP>, or L</CP_KNIGHT>.

=item B<movePiece(MOVE)>

Extracts the piece that does the move.  Returns one of L</CP_KING>,
L</CP_QUEEN>, L</CP_ROOK>, L</CP_BISHOP>, L</CP_KNIGHT>, or L</CP_PAWN>.

=item B<moveLegal(MOVE|NOTATION)>

Returns a truthy value, when the argument is a valid and legal move.  The move
can be given either as an integer returned by L</parseMove> or as a string
that is accepted by L</parseMove>.

=item B<applyMove(MOVE|NOTATION)>

Parses the move given in B<NOTATION> and applies it to the position if the
move is valid and legal.  Otherwise false is returned.  You can also pass
the move as an integer as returned by L</parseMove>.

The method returns state information that can later be used to undo the move
and reset the position to the state it had before the move was applied.

Engines should use the method L</doMove> instead because it is faster.

=item B<unapplyMove(STATE)>

If B<STATE> is state information returned by L</applyMove>, takes back the
move that was given as an argument to L</applyMove>.

Engines should use the method L</undoMove> instead because it is faster.

=item B<doMove(MOVE)>

Applies the move represented by the integer(!) B<MOVE> to the position.  If
the move is legal, the method returns state information that can be used to
undo the move with L</undoMove>.

The method returns false, if the move is illegal.  Note that this is not a
complete legality check but works only for those moves that
L</pseudoLegalMoves> has returned for the current position.

This method is fast and is the one that should be used by engines.

=item B<undoMove(STATE)>

If B<STATE> is state information returned by L</doMove>, takes back the
move that was given as an argument to L</doMove>.

This method is fast and is the one that should be used by engines.

=back

=head2 Methods for Converting Locations

=over 4

=item B<squareToShift(SQUARE)>

Converts B<SQUARE> to a shift.

This is a class method.

=item B<squareToCoordinates(SQUARE)>

Converts B<SQUARE> to coordinates.  It returns a list, not a an array reference.
Be sure to call it in array context!

This is a class method.

=item B<shiftToSquare(SHIFT)>

Converts B<SHIFT> to a square.

This is a class method.

=item B<shiftToCoordinates(SHIFT)>

Converts a shift to coordinates.  It returns a list, not a an array reference.
Be sure to call it in array context!

This is a class method.

=item B<coordinatesToSquare(FILE, RANK)>

Converts coordinates to a square.

This is a class method.

=item B<coordinatesToShift(FILE, RANK)>

Converts coordinates to a shift.

This is a class method.

=back

=head2 Methods for Inspecting a Square

The following methods answer the question which piece of which color occupies
a particular location on the chess board.

=over 4

=item B<pieceAtSquare(SQUARE)>

In array context returns a pair of a piece and a color.  In scalar context,
only the piece is returned.  The piece is one of L</CP_PAWN>, L</CP_KNIGHT>,
L</CP_BISHOP>, L</CP_ROOK>, L</CP_QUEEN>, L</CP_KING>, or L</CP_NO_PIECE> if
the square is empty.

The color is one of L</CP_BLACK> or L</CP_WHITE>.  If the square is empty,
C<undef> is returned instead of a color.

This method is relatively expensive!

=item B<pieceAtCoordinates(FILE, RANK)>

In array context returns a pair of a piece and a color.  In scalar context,
only the piece is returned.  The piece is one of L</CP_PAWN>, L</CP_KNIGHT>,
L</CP_BISHOP>, L</CP_ROOK>, L</CP_QUEEN>, L</CP_KING>, or L</CP_NO_PIECE> if
the square is empty.

The color is one of L</CP_BLACK> or L</CP_WHITE>.  If the square is empty,
C<undef> is returned instead of a color.

This method is relatively expensive!

=item B<pieceAtShift(SHIFT)>

In array context returns a pair of a piece and a color.  In scalar context,
only the piece is returned.  The piece is one of L</CP_PAWN>, L</CP_KNIGHT>,
L</CP_BISHOP>, L</CP_ROOK>, L</CP_QUEEN>, L</CP_KING>, or L</CP_NO_PIECE> if
the square is empty.

The color is one of L</CP_BLACK> or L</CP_WHITE>.  If the square is empty,
C<undef> is returned instead of a color.

This method is relatively expensive!

=back

=head2 Methods for Debugging and Diagnostics

=over 4

=item B<consistent>

Does an extensive consistency check on the position and throws an exception
if any inconsistency is encountered.

=item B<dumpBitboard(BITBOARD)>

Generate a string representation of B<BITBOARD> in ASCII art.

=back

=item B<dumpAll>

Generates a string representation of all bitboards in ASCII art plus some
additional information.

=item B<dumpInfo(INFO)>

Returns a string with the decoded position information as retured by
L</info>.

=item B<movesInCoordinateNotation(MOVES)>

Takes an array of moves (as integers) and converts it into an array of moves
in coordinate notation.

=head1 PROPERTIES

You can access individual properties either by using index constants or by
using accessor macros from L<Chess::Position::Macro>.  All accessor macros
can be assigned to; they are L-values.  But you are strongly advised
to modify properties of a B<Chess::Position> instance only with the methods
documented here.

For getting or setting the bitboard of all white pieces, you have
these options:

    $whites_pieces = $pos->[CP_W_PIECES];
    $white_pieces = cp_w_pieces $pos;
    $white_pieces = cp_w_pieces($pos);
    $pos->[CP_W_PIECES] = $white_pieces;
    cp_w_pieces $pos = $white_pieces;
    cp_w_pieces($pos) = $white_pieces;

The macros (all starting with "cp_") are only available when you have loaded
L<Chess::Position::Macro>, see there for more information.

=over 4

=item B<POS-E<gt>[CP_POS_WHITE_PIECES]>

A bitboard of all white pieces on the board.  Same as L</whitePieces>.

=item B<cp_pos_black_pieces(POS); POS-E<gt>[CP_POS_BLACK_PIECES]>

A bitboard of all black pieces on the board.  Same as L</blackPieces>.

=item B<cp_pos_kings(POS); POS-E<gt>[CP_POS_KINGS]>

A bitboard of all kings (black and white) on the board.

=item B<cp_pos_rooks(POS); POS-E<gt>[CP_POS_ROOKS]>

A bitboard of all rooks (black and white) on the board.  There is no bitboard
for queens.  The queens bitboard can be computed with the bitwise AND of the
rooks and bishops bitboard.

=item B<cp_pos_bishops(POS); POS-E<gt>[CP_POS_BISHOPS]>

A bitboard of all bishops (black and white) on the board. There is no bitboard
for queens.  The queens bitboard can be computed with the bitwise AND of the
rooks and bishops bitboard.

=item B<cp_pos_knights(POS); POS-E<gt>[CP_POS_KNIGHTS]>

A bitboard of all knights (black and white) on the board.

=item B<cp_pos_pawns(POS); POS-E<gt>[CP_POS_PAWNS]>

A bitboard of all pawns (black and white) on the board.

=item B<cp_pos_to_move(POS); POS-E<gt>[CP_POS_TO_MOVE]>

The side to move, either 0 (aka B<CP_WHITE>) or 1 (aka B<CP_BLACK>).

=item B<cp_pos_w_castling(POS); POS-E<gt>[CP_POS_CASTLING]>

Bitmask for castling rights.

=over 8

=item 1 (0x1): white king-side castling

=item 2 (0x2): white queen-side castling

=item 3 (0x4): black king-side castling

=item 4 (0x8): black queen-side castling

=back

=item B<cp_pos_ep_shift(POS); POS-E<gt>[CP_POS_EP_SHIFT]>

The bit-shift offset of an en-passant target square or 0 if en-passant is
not possible.

Note: 0 is the shift of the h1 square but en-passant on h1 is not possible.
It is therefore safe to use it as in boolean context here.

=item B<cp_pos_w_king_shift(POS); POS-E<gt>[CP_POS_W_KING_SHIFT]>

The bit-shift offset to the white king square.

=item B<cp_pos_b_king_shift(POS); POS-E<gt>[CP_POS_B_KING_SHIFT]>

The bit-shift offset to the black king square.

=item B<cp_pos_in_check(POS); POS-E<gt>[CP_POS_IN_CHECK]>

Set to the bitboard of pieces giving check, if the side to move is in check.

=back

=head1 EXPORT TAGS

The module exports only constants, all prefixed with "CP_".

Note that (lowercase) macros "cp_" are defined by using
L<Chess::Position::Macro>.

=head2 All Constants (:all)

You can import all constants with the export tag ":all".

=head2 Accessor Indexes (:accessors)

=head3 CP_POS_WHITE_PIECES

The index of the white bitboard.

=head3 CP_POS_BLACK_PIECES

The index of the black bitboard.

=head3 CP_POS_PAWNS

The index of the pawns bitboard.

=head3 CP_POS_KNIGHTS

The index of the knights bitboard.

=head3 CP_POS_BISHOPS

The index of the bishops bitboard.

=head3 CP_POS_ROOKS

The index of the rooks bitboard.

=head3 CP_POS_KINGS

The index of the kings bitboard.

=head3 CP_POS_HALF_MOVE_CLOCK

The index of the half-move clock.

=head3 CP_POS_HALF_MOVES

The index of the number of half-moves made.

=head3 CP_POS_INFO

The index of the additional position info

=head3 CP_POS_IN_CHECK

The index of the in-check bitboard.

=head2 Piece Constants (:pieces)

=head3 CP_WHITE =E<gt> 0

Symbolic constant for white pieces, side to move, and so on.

=head3 CP_BLACK =C<gt> 1

Symbolic constant for black pieces, side to move, and so on.  Actually, usage
of this constant is avoided internally so that any truthy value can be used.
Most of the time, this is simply the else branch of a conditional.

=head3 CP_NO_PIECE =E<gt> 0

Symbolic constant for no piece.

=head3 CP_PAWN

Symbolic constant for a pawn.

=head3 CP_KNIGHT

Symbolic constant for a knight.

=head3 CP_BISHOP

Symbolic constant for a bishop.

=head3 CP_ROOK

Symbolic constant for a rook.

=head3 CP_QUEEN

Symbolic constant for a queen.

=head3 CP_KING

Symbolic constant for a king.

=head3 CP_PAWN_VALUE =E<gt> 100

Value of a pawn in centipawns.  Feel free to override this constant in derived
classes.

=head3 CP_KNIGHT_VALUE =E<gt> 300

Value of a knight in centipawns.  Feel free to override this constant in derived
classes.

=head3 CP_BISHOP_VALUE =E<gt> 300

Value of a bishop in centipawns.  Feel free to override this constant in derived
classes.

=head3 CP_ROOK_VALUE =E<gt> 500

Value of a rook in centipawns.  Feel free to override this constant in derived
classes.

=head3 CP_QUEEN_VALUE =E<gt> 900

Value of a queen in centipawns.  Feel free to override this constant in derived
classes.

Note that there is no value for a king.  This is on purpose.

=head3 CP_PIECE_CHARS

An array of arrays that maps numeric piece constants (C<CP_PAWN>, C<CP_KNIGHT>,
...) to characters.  The first array are uppercase letters, normally used
for white pieces, the second one are lowercase letters, normally used for
black pieces.

Example to get the character for a black knight:

    $char = CP_PIECE_CHARS->[CP_BLACK]->[CP_KNIGHT];

=head2 Board Constants (:board)

=head3 CP_A_MASK =E<gt> 0x8080808080808080

Bit masks for all squares on the "a" file.

=head3 CP_B_MASK =E<gt> 0x4040404040404040

Bit masks for all squares on the "b" file.

=head3 CP_C_MASK =E<gt> 0x2020202020202020

Bit masks for all squares on the "c" file.

=head3 CP_D_MASK =E<gt> 0x1010101010101010

Bit masks for all squares on the "d" file.

=head3 CP_E_MASK =E<gt> 0x0808080808080808

Bit masks for all squares on the "e" file.

=head3 CP_F_MASK =E<gt> 0x0404040404040404

Bit masks for all squares on the "f" file.

=head3 CP_G_MASK =E<gt> 0x0202020202020202

Bit masks for all squares on the "g" file.

=head3 CP_H_MASK =E<gt> 0x0101010101010101

Bit masks for all squares on the "h" file.

=head3 CP_1_MASK =E<gt> 0x00000000000000ff

Bit masks for all squares on the 1st rank.

=head3 CP_2_MASK =E<gt> 0x000000000000ff00

Bit masks for all squares on the 2nd rank.

=head3 CP_3_MASK =E<gt> 0x0000000000ff0000

Bit masks for all squares on the 3rd rank.

=head3 CP_4_MASK =E<gt> 0x00000000ff000000

Bit masks for all squares on the 4th rank.

=head3 CP_5_MASK =E<gt> 0x000000ff00000000

Bit masks for all squares on the 5th rank.

=head3 CP_6_MASK =E<gt> 0x0000ff0000000000

Bit masks for all squares on the 6th rank.

=head3 CP_7_MASK =E<gt> 0x00ff000000000000

Bit masks for all squares on the 7th rank.

=head3 CP_8_MASK =E<gt> 0xff00000000000000

Bit masks for all squares on the 8th rank.

=head3 CP_FILE_A =E<gt> 0

0-based number of the "a" file.

=head3 CP_FILE_B =E<gt> 1

0-based number of the "b" file.

=head3 CP_FILE_C =E<gt> 2

0-based number of the "c" file.

=head3 CP_FILE_D =E<gt> 3

0-based number of the "d" file.

=head3 CP_FILE_E =E<gt> 4

0-based number of the "e" file.

=head3 CP_FILE_F =E<gt> 5

0-based number of the "f" file.

=head3 CP_FILE_G =E<gt> 6

0-based number of the "g" file.

=head3 CP_FILE_H =E<gt> 7

0-based number of the "h" file.

=head3 CP_RANK_1 =E<gt> 0

0-based number of the 1st rank

=head3 CP_RANK_2 =E<gt> 1

0-based number

=head3 CP_RANK_3 =E<gt> 2

0-based number of the 3rd rank

=head3 CP_RANK_4 =E<gt> 3

0-based number of the 4th rank.

=head3 CP_RANK_5 =E<gt> 4

0-based number of the 5th rank.

=head3 CP_RANK_6 =E<gt> 5

0-based number of the 6th rank.

=head3 CP_RANK_7 =E<gt> 6

0-based number of the 7th rank.

=head3 CP_RANK_8 =E<gt> 7

0-based number of the 8th rank.

=head2 Magic Moves Resp. Magic Bitboard Constants (:magicmoves)

These are all large data tables that are used internally for the magic
bitboards that generate the attack masks for the sliding pieces (queens,
bishops, and rooks).  See the source if you are curious.  Otherwise just import
them if you want to use the macros C<cp_mm_bmagic()> and C<cp_mm_rmagic()>.

=head3 CP_MAGICMOVES_B_MAGICS

Internal.

=head3 CP_MAGICMOVES_R_MAGICS

Internal.

=head3 CP_MAGICMOVES_B_MASK

Internal.

=head3 CP_MAGICMOVES_R_MASK

Internal.

=head3 CP_MAGICMOVESBDB

Internal.

=head3 CP_MAGICMOVESRDB

Internal.

=head1 OTHER

=head2 TERMINOLOGY

=head3 SHIFT

A "shift" is a number from 0-63 that denotes how many places a lone 1 has to
be bit-shifted to the left in order to create a mask for selecting a single
square of the chess board.  The square "a8" has a shift of 63, the square "h1"
has a shift of 0.

You can think of it as the 0-based bit number.

=head3 SHIFT MASK

A shift mask is a lone 1 bit-shifted a number of places to the left, so that
it can be used as a mask for selecting a single square of the chess board.

=head3 SQUARE

A square is one square resp. field of the chess board.  If used in method names,
constants or variable names, it is a conventional specification like "e4" or
"c5".

=head3 COORDINATES

Coordinates are a pair of two integers, a file (1st) and a rank (2nd).  Both
of them have a valid range of 0-7.

=head1 COPYRIGHT

Copyright (C) 2021 Guido Flohr <guido.flohr@cantanea.com>.

=head1 SEE ALSO

L<Chess::Position::Macro>, perl(1)